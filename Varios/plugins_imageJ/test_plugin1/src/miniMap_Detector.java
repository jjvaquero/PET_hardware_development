/*
 *  @author Rigoberto Chil, rchil@hggm.es, Lab. Imagen Médica
 *  @version $Revision: 1.1 
 *  @Date:14/01/2014   
 * 
 *  Class used to detect the faulty detectors on the minimap.raw images
 *  generated by UCM for the SuperArgus PET system
 *   
 */
import ij.IJ;
import ij.gui.Roi;
import ij.ImagePlus;
import ij.process.ImageProcessor;
import ij.process.ImageStatistics;
import ij.measure.Calibration;
import ij.measure.Measurements;
import ij.util.ArrayUtil;


public class miniMap_Detector  {
	ImageProcessor myProc;
	Roi[] miniMapRois;
	//variables used in the classification
	//if needed they should be modified to get to improve the classification
	float lysoMeanFactor;
	float lysoStdFactor;
	float gsoMeanFactor;
	float gsoStdFactor;
	//minimap characteristics
	public static int sizeX = 24; 
	public static int sizeY = 12;
	public static int miniMapWidth = 336;
	public static int miniMapHeight = 168;
	public static int detectorSize = 12;
	
	
	public miniMap_Detector(){
		//variables used in the classification of the detectors
		//if needed they should be modified to get to improve the classification
		lysoMeanFactor = 2;
		lysoStdFactor = 2;
		gsoMeanFactor = 2;
	    gsoStdFactor = 2;
		
		// generate the ROIs that will be analyzed later on
		miniMapRois = new Roi[sizeX*sizeY];
		int index = 0;
		for (int y = 0; y <sizeY; y++){
			for ( int x = 0; x < sizeX; x++){
				// each ROI is a 12x12 square
				miniMapRois[index] = new Roi(x*(detectorSize+2),y*(detectorSize+2),detectorSize,detectorSize);
				index++;
			}

		}
	}

		
    public int[] Analyze(ImagePlus img) {   	
		//get the Image processor for the file that have been sent
		myProc = img.getProcessor();
		
		if (this.checkImageSize(myProc) > 0) return null;


		ImageProcessor tmpProc;  // extra image processor needed to work with the cropped versions
		ImageStatistics nStats = new ImageStatistics(); //
		Calibration nCal = img.getCalibration(); //calibration data needed by the getStatistics
		// I will need different arrays for the LYSO and the GSO 
		float[] LYSOmeans = new float[sizeX*sizeY/2];
		float[] LYSOstds = new float[sizeX*sizeY/2];
		float[] GSOmeans = new float[sizeX*sizeY/2];
		float[] GSOstds = new float[sizeX*sizeY/2];
		
		int index = 0;
				
		
		//Divide the image in different ROIs and measure the mean and the std 
		//of the ROIs, ROIs will be stored in an array in case they are needed afterwards
		for (int y = 0; y <sizeY; y++){
			for ( int x = 0; x < sizeX; x++){
				// each ROI is a 12x12 square
				myProc.setRoi(miniMapRois[index]);
				// obtain a new image processor to get it's statistics
				tmpProc = myProc.crop();
				//get the data needed
				nStats = ImageStatistics.getStatistics(tmpProc, Measurements.MEAN+Measurements.STD_DEV,nCal); //6 = MEAN + STD_DEV
				//nStats = tmpProc.getStatistics(); // this gave worst results than the methon currently used
				if (y < sizeY/2){
					LYSOmeans[index] = (float) nStats.mean;
					LYSOstds[index] = (float) nStats.stdDev;
				}else{
					GSOmeans[index-(sizeX*sizeY/2)] = (float) nStats.mean;
					GSOstds[index-(sizeX*sizeY/2)] = (float) nStats.stdDev;
				}

				index++;	
				//next line is commented because there is no need to check the ImageJ log data
				//IJ.log("Cristal "+ String.valueOf(index-1)+ " media "+ String.valueOf(nStats.mean) + "desv "+String.valueOf(nStats.stdDev));
				//to make sure that ROIs are not added one to the other
				myProc.resetRoi();
				}			

		}
		
		
		//to get the means from the 4 arrays, I will need an ArrayUtil object
		ArrayUtil aUtil = new ArrayUtil(LYSOmeans);
		float LYSOmeanVal = (float)aUtil.getMean();
		aUtil = new ArrayUtil(LYSOstds);
		float LYSOstdMean = (float) aUtil.getMean();
		aUtil = new ArrayUtil(GSOmeans);
		float GSOmeanVal = (float) aUtil.getMean();
		aUtil = new ArrayUtil(GSOstds);
		float GSOstdMean = (float) aUtil.getMean();

		//variables used in the classification
		int lysoMeanFactor = 2;
		int lysoStdFactor = 2;
		int gsoMeanFactor = 2;
		int gsoStdFactor = 2;
		
		//finally I will store which detectors are faulty
		//using the mean and the std for the classification
		//this can be tuned by modifying the meanFactors and stdFactos
		//on the class constructor
		int[] wrongDetector = new int[sizeX*sizeY];
	    int nWrong = 0;
	    int n = sizeX*sizeY;

		for (int i = 0; i < n/2; i ++){
	    		wrongDetector[i] = 0;
			    wrongDetector[n/2+i] = 0;
			if (LYSOmeans[i] < (LYSOmeanVal-LYSOmeanVal/lysoMeanFactor)){
				wrongDetector[i] = 1;
				nWrong++;
			}
			else if (LYSOstds[i] > (LYSOstdMean*lysoStdFactor)){
				wrongDetector[i] = 1;
				nWrong++;
			}
		
			if (GSOmeans[i] < (GSOmeanVal-GSOmeanVal/gsoMeanFactor) || GSOmeans[i] > (GSOmeanVal+GSOmeanVal/gsoMeanFactor)){
				wrongDetector[n/2+i] = 1;
				nWrong++;
			}
			else if (GSOstds[i] > (GSOstdMean*gsoStdFactor)){
				wrongDetector[n/2+i] = 1;
				nWrong++;
			}
		}
		
		//Now I can plot the wrong crystals;
		//this.drawRois(myProc, wrongCrystal);
		//To show the number of wrong detectors found on this minimap
		//IJ.log("Wrong detectors "+String.valueOf(nWrong));
		
		//function needs to be called in order to see the modifications 
		// done to the original image
		//img.updateAndDraw();
		
		return wrongDetector;
	}
    
    public void drawRois(ImageProcessor imgProc, int[] wrongCrystals){
    	int n = sizeX*sizeY;
	    //check that the image has the correct size
		if (this.checkImageSize(imgProc) > 0) return;
		//Now I can plot the wrong crystals;
		imgProc.setColor(0xFFFFFF);
		for(int i = 0; i < n; i++){
			if(wrongCrystals[i]>0) imgProc.draw(miniMapRois[i]);
		}		

    }
    
    private int checkImageSize(ImageProcessor imgProc){
    	int height = imgProc.getHeight();
    	int width = imgProc.getWidth();
    	
    	if ( height != miniMapHeight || width != miniMapWidth) return 1;
    	return 0;
    }
    
    public Roi[] getRois(){
    	return this.miniMapRois;
    }
    
    
}