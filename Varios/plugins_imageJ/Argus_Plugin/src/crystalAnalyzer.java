/*
*   @author Rigoberto Chil, rchil@hggm.es, Lab. Imagen Médica
 *  @version $Revision: 1.1 
 *  @Date:14/01/2014   
 *  
 *  Class to be used in the analysis of the lyso.raw and gso.raw
 *  images from UCM for the SuperArgus PET system
 * 
 */
import java.io.PrintWriter;
import java.util.Arrays;
import ij.IJ;
import ij.ImagePlus;
import ij.process.ImageProcessor;
import ij.process.ImageStatistics;
import ij.util.ArrayUtil;
import ij.measure.CurveFitter;
import ij.gui.NewImage;




public class crystalAnalyzer {
	// Original images from the lyso.raw and gso.raw
	ImagePlus LYSOimgPlus;
	ImagePlus GSOimgPlus;
	// Images that will be generated by this calss
	ImagePlus lysoMaxPos;
	ImagePlus lysoFWHM;
	ImagePlus gsoMaxPos;
	ImagePlus gsoFWHM;
	
	ImagePlus FWHMMiniMap;
	ImagePlus photoMiniMap;
	//Image processor that will be used
	ImageProcessor myProc;
//	ImageProcessor LYSOproc;
//	ImageProcessor GSOproc;
		
	ImageProcessor lysoMaxPosProc;
	ImageProcessor lysoFWHMProc; 
	
	ImageProcessor gsoMaxPosProc;
	ImageProcessor gsoFWHMProc; 	

	ImageProcessor FWHMMiniProc; 
	ImageProcessor photoMiniProc;
	
	//miniMap_Detector myAnalyzer;
	ImageStatistics auxStatistics;
	
	//values used on the algorithms
	//values used to detect the thresholds and the slopes
	int thrsVal = 20;
	int meanSize = 10;
	
	//variables used for the miniMaps generation
	int miniMapWidth = miniMapAnalyzer.miniMapWidth; 
	int miniMapHeight = miniMapAnalyzer.miniMapHeight;
	//int miniSquareSize = 13;
	
	int totSlices;
	int imgCalWidth;
	int imgCalHeight;
	
	public crystalAnalyzer(ImagePlus imgLyso, ImagePlus imgGso){
		this.LYSOimgPlus = imgLyso;
		this.GSOimgPlus = imgGso;
		
		totSlices = LYSOimgPlus.getNSlices();
		imgCalWidth = LYSOimgPlus.getWidth();
		//TODO here a check could be included to check the correct image size
		
		//initialize LYSO images
    	lysoMaxPos = NewImage.createByteImage("maxPosMap", totSlices, imgCalWidth, 1, NewImage.FILL_BLACK);
    	lysoFWHM = NewImage.createByteImage("FHWMMaps", totSlices, imgCalWidth, 1, NewImage.FILL_BLACK);
    	//initialize GSO images
    	gsoMaxPos = NewImage.createByteImage("maxPosMap", totSlices, imgCalWidth, 1, NewImage.FILL_BLACK);
    	gsoFWHM = NewImage.createByteImage("FHWMMaps", totSlices, imgCalWidth, 1, NewImage.FILL_BLACK);
    	//initialize the two minimap images
		FWHMMiniMap = NewImage.createByteImage("FWHM_mini", miniMapWidth, miniMapHeight, 1, NewImage.FILL_BLACK);
		photoMiniMap = NewImage.createByteImage("photo_mini", miniMapWidth, miniMapHeight, 1, NewImage.FILL_BLACK);
    	
    	
    	//Initialize the image processor that will be used
//		LYSOproc = LYSOimgPlus.getProcessor();
//		GSOproc = GSOimgPlus.getProcessor();
		
		lysoMaxPosProc = lysoMaxPos.getProcessor();
		lysoFWHMProc = lysoFWHM.getProcessor();
		
		gsoMaxPosProc = gsoMaxPos.getProcessor();
		gsoFWHMProc = gsoFWHM.getProcessor();
		
		
		FWHMMiniProc = FWHMMiniMap.getProcessor(); 
		photoMiniProc = photoMiniMap.getProcessor();
		
		auxStatistics = new ImageStatistics();
		
		
	}
	
	
	//used to get only the maxPos image of one of the crystals
	public ImagePlus getMaxPos(int crystalSel){
		//first I will check what kind of crystal they are asking for
		ImagePlus tmpImg = lysoMaxPos;
		
		switch (crystalSel){
		case 0 : 
			//now I will check if this has not been run before
			auxStatistics = lysoMaxPosProc.getStatistics();
			if (auxStatistics.mean < 1) generateMaxPosFWHM(LYSOimgPlus,lysoMaxPosProc,lysoFWHMProc);
			tmpImg = lysoMaxPos;
			break;
		case 1: 
			auxStatistics = gsoMaxPosProc.getStatistics();
			if (auxStatistics.mean < 1) generateMaxPosFWHM(GSOimgPlus,gsoMaxPosProc,gsoFWHMProc);
			tmpImg = gsoMaxPos;
			break;	
		default: 
			tmpImg = null;
			break;
		}
		
		return tmpImg;		
	}
	
	//used to get the FWHM of one of the crystals
	public ImagePlus getFWHM(int crystalSel){
		//first I will check what kind of crystal they are asking for
		ImagePlus tmpImg = lysoFWHM; 
		switch (crystalSel){
		case 0 : 
			//now I will check if this has not been run before
			auxStatistics = lysoFWHMProc.getStatistics();
			if (auxStatistics.mean < 1) generateMaxPosFWHM(LYSOimgPlus,lysoMaxPosProc,lysoFWHMProc);
			tmpImg = lysoFWHM;
			break;
		case 1: 
			auxStatistics = gsoFWHMProc.getStatistics();
			if (auxStatistics.mean < 1) generateMaxPosFWHM(GSOimgPlus,gsoMaxPosProc,gsoFWHMProc);
			tmpImg = gsoFWHM;
			break;	
		default: 
			tmpImg = null;
			break;
		}		
		return tmpImg;		
	}
	
	//function to get an Array with the maxPos and the FWHM for one of the crystals
	public ImagePlus[] getMaxPos_FWHM(int crystalSel){
		//first I will check what kind of crystal they are asking for
		ImagePlus[] tmpImg = new ImagePlus[2]; 
		switch (crystalSel){
		case 0 : 
			//now I will check if this has not been run before
			auxStatistics = lysoMaxPosProc.getStatistics();
			if (auxStatistics.mean < 1) generateMaxPosFWHM(LYSOimgPlus,lysoMaxPosProc,lysoFWHMProc);
			tmpImg[0] = lysoMaxPos;
			tmpImg[1] = lysoFWHM;
			break;
		case 1: 
			auxStatistics = gsoMaxPosProc.getStatistics();
			if (auxStatistics.mean < 1) generateMaxPosFWHM(GSOimgPlus,gsoMaxPosProc,gsoFWHMProc);
			tmpImg[0] = gsoMaxPos;
			tmpImg[1] = gsoFWHM;
			break;	
		default: 
			tmpImg = null;
			break;
		}		
		return tmpImg;		
	}
	
	//function used to get the miniMaps
	public ImagePlus[] getMiniMaps(){
		//first I will check what kind of crystal they are asking for
		ImagePlus[] tmpImg = new ImagePlus[2]; 
		ImageProcessor MaxProc;
		ImageProcessor FWHMProc;

	    //now I will check if this has not been run before
		auxStatistics = photoMiniProc.getStatistics();
		if (auxStatistics.mean < 1){
			//first I will have to be sure that the maxPos and FWHM images 
			//have been populated previously for the two crsytals
			this.getMaxPos(0); //first the lyso crystal
			this.getMaxPos(1); // now the gso 
			
			
			MaxProc = lysoMaxPos.getProcessor();
			FWHMProc = lysoFWHM.getProcessor();
			createMiniMap(photoMiniProc,FWHMMiniProc,0,MaxProc,FWHMProc);
			
			MaxProc = gsoMaxPos.getProcessor();
			FWHMProc = gsoFWHM.getProcessor();
			createMiniMap(photoMiniProc,FWHMMiniProc,6,MaxProc,FWHMProc);
		}
		
		tmpImg[0] = photoMiniMap;
		tmpImg[1] = FWHMMiniMap;
		return tmpImg;		
	}
	
	//save the photopeaks and FWHM data to csv files
	public void exportTXT(String path) throws Exception{
		//first I will have to be sure that the maxPos and FWHM images 
		//have been populated previously for the two crsytals
		this.getMaxPos(0); //first the lyso crystal
		this.getMaxPos(1); // now the gso 
		
	    try{
	    	int[] tmpData = new int[lysoMaxPosProc.getHeight()];
	    	int lWidth = lysoMaxPosProc.getWidth();
	    	
	    	//first I will print the peaks
	    	PrintWriter mPrinter =   new PrintWriter(path+"/photopeaks.csv");
	    	String tmpStr; 
	    	//first I will print the Lyso crystals
	    	for(int i = 0;  i < lWidth; i++){
	    		lysoMaxPosProc.getColumn(i, 0,tmpData, lysoMaxPosProc.getHeight());
	    		tmpStr = Arrays.toString(tmpData);
	    		tmpStr = tmpStr.replace('[', ' ');
	    		tmpStr = tmpStr.replace(']', ' ');
		    	mPrinter.println(tmpStr);	    		
	    	}
	    	//and now the GSO crystals
	    	for(int i = 0;  i < lWidth; i++){
	    		gsoMaxPosProc.getColumn(i, 0,tmpData, gsoMaxPosProc.getHeight());
	    		tmpStr = Arrays.toString(tmpData);
	    		tmpStr = tmpStr.replace('[', ' ');
	    		tmpStr = tmpStr.replace(']', ' ');
		    	mPrinter.println(tmpStr);	    		
	    	}   	
	    	mPrinter.close();
	    	
	    	
	    	//now I will print the FWHM
	    	mPrinter =   new PrintWriter(path+"/fwhm.csv");
	    	//first the LYSO
	    	for(int i = 0;  i < lWidth; i++){
	    		lysoFWHMProc.getColumn(i, 0,tmpData, lysoFWHMProc.getHeight());
	    		tmpStr = Arrays.toString(tmpData);
	    		tmpStr = tmpStr.replace('[', ' ');
	    		tmpStr = tmpStr.replace(']', ' ');
		    	mPrinter.println(tmpStr);	    		
	    	}
	    	//now the GSO
	    	for(int i = 0;  i < lWidth; i++){
	    		gsoFWHMProc.getColumn(i, 0,tmpData, gsoFWHMProc.getHeight());
	    		tmpStr = Arrays.toString(tmpData);
	    		tmpStr = tmpStr.replace('[', ' ');
	    		tmpStr = tmpStr.replace(']', ' ');
		    	mPrinter.println(tmpStr);	    		
	    	}	 
	    	mPrinter.close();
	    	
	    }
		catch(Exception e){
			IJ.log(e.getMessage());
		}
	}
	
	
	public void exportTXT2(String path) throws Exception{
		//first I will have to be sure that the maxPos and FWHM images 
		//have been populated previously for the two crsytals
		this.getMaxPos(0); //first the lyso crystal
		this.getMaxPos(1); // now the gso 
		
	    try{
	    	int[] tmpData = new int[lysoMaxPosProc.getWidth()];
	    	int lHeight = lysoMaxPosProc.getHeight();
	    	
	    	//first I will print the peaks
	    	PrintWriter mPrinter =   new PrintWriter(path+"/photopeaks.csv");
	    	String tmpStr; 
	    	//first I will print the Lyso crystals
	    	for(int i = 0;  i < lHeight; i++){
	    		lysoMaxPosProc.getRow(i, 0,tmpData, lysoMaxPosProc.getWidth());
	    		tmpStr = Arrays.toString(tmpData);
	    		tmpStr = tmpStr.replace('[', ' ');
	    		tmpStr = tmpStr.replace(']', ' ');
		    	mPrinter.println(tmpStr);	    		
	    	}
	    	//and now the GSO crystals
	    	for(int i = 0;  i < lHeight; i++){
	    		gsoMaxPosProc.getRow(i, 0,tmpData, gsoMaxPosProc.getWidth());
	    		tmpStr = Arrays.toString(tmpData);
	    		tmpStr = tmpStr.replace('[', ' ');
	    		tmpStr = tmpStr.replace(']', ' ');
		    	mPrinter.println(tmpStr);	    		
	    	}   	
	    	mPrinter.close();
	    	
	    	
	    	//now I will print the FWHM
	    	mPrinter =   new PrintWriter(path+"/fwhm.csv");
	    	//first the LYSO
	    	for(int i = 0;  i < lHeight; i++){
	    		lysoFWHMProc.getRow(i, 0,tmpData, lysoFWHMProc.getWidth());
	    		tmpStr = Arrays.toString(tmpData);
	    		tmpStr = tmpStr.replace('[', ' ');
	    		tmpStr = tmpStr.replace(']', ' ');
		    	mPrinter.println(tmpStr);	    		
	    	}
	    	//now the GSO
	    	for(int i = 0;  i < lHeight; i++){
	    		gsoFWHMProc.getRow(i, 0,tmpData, gsoFWHMProc.getWidth());
	    		tmpStr = Arrays.toString(tmpData);
	    		tmpStr = tmpStr.replace('[', ' ');
	    		tmpStr = tmpStr.replace(']', ' ');
		    	mPrinter.println(tmpStr);	    		
	    	}	 
	    	mPrinter.close();
	    	
	    }
		catch(Exception e){
			IJ.log(e.getMessage());
		}
	}
	

    
    //extra functions used by the other members of the class
   //function to work with the image that contains all the max pixels
    private int[] findThresholsdIndex(ImageProcessor imgProc,int threshold){
  	
    	int height = imgProc.getHeight();
    	int width = imgProc.getWidth();
    	int[] thrsIndexs = new int[width];

    	int j = height - 10;
    	for (int i = 0; i < width; i++){
    		while( ((imgProc.getPixel(i,j) - 32768)< threshold) && (j > 10)){j--;}
    		thrsIndexs[i] = j;
    		j = height - 10;	
    	}

    	return thrsIndexs;
    }

    private int findFWHM(double[] dataArray, int maxValue, int length){
    	double midValue = maxValue/2;
    	int indMid1 = 0;
    	int indMid2 = 0;
    	//find the first index 
    	int i = 0;
    	while( dataArray[i] < midValue){
    		i++;
    	}
    	indMid1 = i;
    	i = length-1;
    	while( dataArray[i] < midValue){
    		i--;
    	}
    	indMid2 = i; 
    	int FWHM = indMid2 - indMid1;
    	return FWHM;
    }
    
    
    /*function used to find the changes in the slope
     * 
     *  dir = 1 --> ascending, dir = -1 --> descending
     *  startIndex --> index where the algorithm will start
     *  dataArray
     *  moveDir = 1 --> forward, moveDir = -1 --> backward
     *  numMean --> number of values used to calculate the next mean
     * 
     */
    private int findSlopeChange(int[] dataArray,int startIndex,int dir,int moveDir,int numMean){
    	int currIndex = startIndex; // -5 to adjust for the while loop
    	int currMean = dir; 
    	int prevMean = 0; 
    	while ( (currMean - prevMean)*dir > 0 ){
    		currIndex+=moveDir;
    		prevMean = currMean;
    		currMean = 0;
     		for (int i = 0; i< numMean; i++){
     			//check that i dont get out of the array
     			if ( (currIndex+(i*moveDir) < 256) && (currIndex+(i*moveDir)>0)){
     				currMean += dataArray[currIndex+(i*moveDir)];
     			}
    		}
    		currMean/= numMean;	
    	
    	}
    	return currIndex;
    	
    	
    }
    
    /*
     * function that returns the position of the photopeak and the FWHM for each column in an image
     * data is returned in a single array because imageJ macros does not support multi dimension arrays
     * imgName --> name of the image that will be used
     * slcie --> slice to use, this is added to be able to work with multiSlice images
     * threshold --> thresold from wich to start looking for the maximum
     * numMean --> number of values used to compute the mean on the slope detection algorithm
     */
    private  int[] findMaxPos_FWHM(ImageProcessor imgProc,int nSlice,int threshold,int numMean){

    	imgProc.setSliceNumber(nSlice);

    	//find the indexes where the values reach the given threshold
    	int width =imgProc.getWidth();
    	int height = imgProc.getHeight();
    	int[] thrsArray = new int[width];
    	thrsArray =  findThresholsdIndex(imgProc,threshold);

    	int[] index1 = new int[width];
    	int[] index2 = new int[width];
    	int[]tmpProfArray = new int[height];

    	//values that I will save
    	int[] minVals = new int[width];
    	int[] maxVals = new int[width];
    	int[] FWHMValues = new int[width];
    	int[] maxPos = new int [width];


    	//array to store the results
    	int[]results = new int[width*2];

    	for (int i = 0; i< width; i++){
    		//first i will get the array of the corresponding detector
    		imgProc.getColumn(i, 0, tmpProfArray, height);
    		// find the two points where the slope changes to get the whole peak
    		index1[i] = findSlopeChange(tmpProfArray, thrsArray[i],1,-1,10);
    		index2[i] = findSlopeChange(tmpProfArray, (index1[i]-30),-1,-1,10);

    		//error check
    		if (((thrsArray[i] - index2[i]) > 0) && (index2[i]>0) ){
    			double[] tmpArrayY = new double[thrsArray[i]- index2[i]];
    			double[] tmpArrayX = new double[thrsArray[i]- index2[i]];
    		
    			//copy only the peak to a new array
    			for (int j = 0; j< (thrsArray[i]-index2[i]); j++){
    				tmpArrayY[j] = tmpProfArray[index2[i]+j];
    				tmpArrayX[j] = j;
    			}
    	       		//fit a Guassian curve to it
    	       		CurveFitter cFit = new CurveFitter(tmpArrayX,tmpArrayY);
    	       		cFit.doFit(CurveFitter.GAUSSIAN);
    	       		
    	       		double[] tmpArray = new double[thrsArray[i]-index2[i]];	
    	       		//TODO fix this, using another variable because
    	       		//array util constructor only takes floats....
    	       		float[] tmpsasa = new float[thrsArray[i]-index2[i]];	

    	      		//for (int j = 0; j< (thrsArray[i]- index2[i]); j++){
    	      			//tmpArray[j] = Fit.f(j);
    	     
    			   //}
    	       		//TODO can't type cast to float[]....
    	       		tmpArray = cFit.getYPoints();
    	       		for (int j = 0; j< (thrsArray[i]- index2[i]); j++){
    	       			tmpsasa[j] = (float) tmpArray[j];
    	       		}
    			//now I can find the values that I want
    			minVals[i] =(int) tmpArray[0];
    			ArrayUtil aUtil = new ArrayUtil(tmpsasa);
    		    maxVals[i] = (int)aUtil.getMaximum(); 
    			
    		    double[] fitParams = new double[cFit.getNumParams()];
    		    fitParams = cFit.getParams();
    		    FWHMValues[i] =(int)(2.355*fitParams[3]);
    			//this is done because imageJ curveFitter fails sometimes
    			if (FWHMValues[i] > 150){
    				FWHMValues[i]  = findFWHM(tmpArray, maxVals[i], (thrsArray[i]-index2[i]));
    			}
    		
    		
    			//find the position of maximum value in the profile/energy spectrum
    			int j = 0; 
    			while( tmpArray[j] != maxVals[i]){j++;}
    			maxPos[i] = index2[i]+j;
    		
    		
    		} 

    		// In case we want to show this data on the ImageJ log
    		//IJ.log("Detector "+i+", Max "+maxVals[i]+" Pos: "+maxPos[i]+" Min: "+minVals[i]+" FWHM :"+FWHMValues[i]);
    		//now i save the values in one array
    		results[i] = maxPos[i];
    		results[(i+width)] = FWHMValues[i];
    	}
    	
    	return results;
    	
    }
    
    /*
     *  function used to create the minimaps
     *  maxPosMiniMap --> name of the maxPos miniMap image
     *  FWHMMiniMap --> name of the FWHM mini map image
     *  type --> 0 = lyso, 6 = gso
     *  maxPosMap -->maxPos
     */
    private void createMiniMap(ImageProcessor maxPosMiniMap,ImageProcessor FWHMMiniMap,int type,ImageProcessor maxPosMap,ImageProcessor FWHMMap){

    	int height = maxPosMap.getHeight();
    	int width = maxPosMap.getWidth();
    	
    	//here the column values will be stored
    	int[] profValues1 = new int[height];
    	int[] profValues2 = new int[height];

    	int indYimg =0;
    	int indXimg =0;

    	for(int  i = 0; i< width; i++){
    		maxPosMap.getColumn(i, 0, profValues1, height);
    		FWHMMap.getColumn(i, 0, profValues2, height);
    		int currIndex = 0;

            //plotting the pixels directly to reorder the image as the minimap
    		indYimg = i%6+type;
    		if(indYimg == type && i > 0){
    			indXimg++;
    		}
    	
    		for(int j = 0; j< 13; j++){
    			for(int k = 0; k<13; k++){		
    				maxPosMiniMap.putPixel((k+(indXimg*14)),(j+(indYimg*14)),profValues1[currIndex]);
    				FWHMMiniMap.putPixel((k+(indXimg*14)),(j+(indYimg*14)),profValues2[currIndex]);
    				currIndex++;			
    			}
    		}
    	}
    }
    
    private void generateMaxPosFWHM(ImagePlus inputImg, ImageProcessor maxPosMap, ImageProcessor FWHMMap){
    	
    	ImageProcessor inputImgProc = inputImg.getProcessor();
    	int width = inputImg.getWidth();
    	int[] vals = new int[width*2];
    	
    	// this will be done once per detector, one detector = one slice
    	for (int i = 0; i< totSlices; i++) {  
    		//set the current slice
    		inputImg.setZ(i+1);
    		//TODO try commenting the next line
    		inputImgProc = inputImg.getProcessor();
    		vals = findMaxPos_FWHM(inputImgProc,i+1,thrsVal,meanSize);
    		for(int j = 0; j<width; j++){
    			maxPosMap.putPixel(i, j, vals[j]);
    			FWHMMap.putPixel(i, j, vals[j+width]);
    		}
    	}
    }
    
}