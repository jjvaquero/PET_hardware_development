import ij.IJ;
import ij.gui.Roi;
//import ij.plugin.frame.RoiManager;
import ij.ImagePlus;
import ij.process.ImageProcessor;
import ij.io.*;
import ij.plugin.*;
import ij.process.ImageStatistics;
import ij.measure.Calibration;
import ij.measure.Measurements;
import ij.util.ArrayUtil;
import ij.measure.CurveFitter;


public class crystal_peak_correction implements PlugIn {
	ImagePlus imgLYSO;
	ImagePlus img;
	ImagePlus imgGSO;
	
	ImageProcessor myProc;
	ImageProcessor LYSOproc;
	ImageProcessor GSOProc;
	
		
    public void run(String arg) {
		//first I will open the new miniMap image
		ImportDialog impDiag = new ImportDialog("lyso.raw","C:/Users/rchil/Desktop/Detect_SuperArgus");
		FileInfo fInf = impDiag.getFileInfo();
		OpenDialog myDiag= new OpenDialog("Load LYSO crystal");
		fInf.fileName = myDiag.getFileName();		
		fInf.directory = myDiag.getDirectory();
		FileOpener fOpen = new FileOpener(fInf);
		
		
		img = fOpen.open(true);
		// work will be done on this image processor object
		myProc = img.getProcessor();

		int sizeX = 24; 
		int sizeY = 12;
		ImageProcessor tmpProc;  // extra image processor needed to work with the cropped versions
		ImageStatistics nStats = new ImageStatistics(); //
		Calibration nCal = img.getCalibration(); //calibration data needed by the getStatistics
		// I will need different arrays for the LYSO and the GSO 
		float[] LYSOmeans = new float[sizeX*sizeY/2];
		float[] LYSOstds = new float[sizeX*sizeY/2];
		float[] GSOmeans = new float[sizeX*sizeY/2];
		float[] GSOstds = new float[sizeX*sizeY/2];
		/*
		double[]  means = new double[sizeX*sizeY];
		double[] stdDevs = new double[sizeX*sizeY];
		*/
		
		Roi [] rois = new Roi[sizeX*sizeY];
		int index = 0;
		
		img.updateAndDraw();
		
		
		//Divide the image in different ROIs and measure the mean and the std 
		//of the ROIs, ROIs will be stored in an array in case they are needed afterwards
		for (int y = 0; y <sizeY; y++){
			for ( int x = 0; x < sizeX; x++){
				// each ROI is a 12x12 square
				rois[index] = new Roi(x*14,y*14,12,12);
				myProc.setRoi(rois[index]);
				// obtain a new image processor to get it's statistics
				tmpProc = myProc.crop();
				//get the data needed
				nStats = ImageStatistics.getStatistics(tmpProc, Measurements.MEAN+Measurements.STD_DEV,nCal); //6 = MEAN + STD_DEV
				if (y < sizeY/2){
					LYSOmeans[index] = (float) nStats.mean;
					LYSOstds[index] = (float) nStats.stdDev;
				}else{
					GSOmeans[index-(sizeX*sizeY/2)] = (float) nStats.mean;
					GSOstds[index-(sizeX*sizeY/2)] = (float) nStats.stdDev;
				}
				//means[index] = nStats.mean;
				//stdDevs[index] = nStats.stdDev;
				//myProc.draw(rois[index]);
				index++;	
				//used only to check that it works, can be commented later on
				//IJ.log("Cristal "+ String.valueOf(index-1)+ " media "+ String.valueOf(nStats.mean) + "desv "+String.valueOf(nStats.stdDev));
				//to make sure that ROIs are not added one to the other
				myProc.resetRoi();
				}			

		}
		
		//Now I try the same implementation as before...to see how it works...
		
		//to get the means from the 4 arrays, I will need an ArrayUtil object
		ArrayUtil aUtil = new ArrayUtil(LYSOmeans);
		float LYSOmeanVal = (float)aUtil.getMean();
		aUtil = new ArrayUtil(LYSOstds);
		float LYSOstdMean = (float) aUtil.getMean();
		aUtil = new ArrayUtil(GSOmeans);
		float GSOmeanVal = (float) aUtil.getMean();
		aUtil = new ArrayUtil(GSOstds);
		float GSOstdMean = (float) aUtil.getMean();

		//variables used in the classification
		int lysoMeanFactor = 2;
		int lysoStdFactor = 2;
		int gsoMeanFactor = 2;
		int gsoStdFactor = 2;
		
		int[] wrongCrystal = new int[sizeX*sizeY];
	    int nWrong = 0;
	    int n = sizeX*sizeY;

		for (int i = 0; i < n/2; i ++){
	    		wrongCrystal[i] = 0;
			    wrongCrystal[n/2+i] = 0;
			if (LYSOmeans[i] < (LYSOmeanVal-LYSOmeanVal/lysoMeanFactor)){
				wrongCrystal[i] = 1;
				nWrong++;
			}
			else if (LYSOstds[i] > (LYSOstdMean*lysoStdFactor)){
				wrongCrystal[i] = 1;
				nWrong++;
			}
		
			if (GSOmeans[i] < (GSOmeanVal-GSOmeanVal/gsoMeanFactor) || GSOmeans[i] > (GSOmeanVal+GSOmeanVal/gsoMeanFactor)){
				wrongCrystal[n/2+i] = 1;
				nWrong++;
			}
			else if (GSOstds[i] > (GSOstdMean*gsoStdFactor)){
				wrongCrystal[n/2+i] = 1;
				nWrong++;
			}
		}
		
		//Now I can plot the wrong crystals;
		myProc.setColor(0xFFFFFF);
		for(int i = 0; i < n; i++){
			if(wrongCrystal[i]>0) myProc.draw(rois[i]);
		}
		IJ.log("Cristales mal "+String.valueOf(nWrong));
		
		//function needs to be called in order to see the modifications 
		// done to the original image
		img.updateAndDraw();
		
		//annado todas las roi a un roi manager
		//not needed can be taken out later
		/*RoiManager roiM = new RoiManager();
		for(int i = 0 ; i < sizeX*sizeY ; i++){
			roiM.addRoi(rois[i]);
		}*/
	}

    
    //extra functions used by the other members of the class
  //function to work with the image that contains all the max pixels
    private int[] findThresholsdIndex(ImageProcessor imgProc,int threshold){
    	//selectImage(imgName);  	
    	int height = imgProc.getHeight();
    	int width = imgProc.getWidth();
    	int[] thrsIndexs = new int[width];

    	int j = height - 10;
    	for (int i = 0; i < width; i++){
    		while( ((imgProc.getPixel(i,j) - 32768)< threshold) && (j > 10)){j--;}
    		thrsIndexs[i] = j;
    		j = height - 10;	
    	}

    	return thrsIndexs;
    }

    private int findFWHM(double[] dataArray, int maxValue, int length){
    	double midValue = maxValue/2;
    	int indMid1 = 0;
    	int indMid2 = 0;
    	//find the first index 
    	int i = 0;
    	while( dataArray[i] < midValue){
    		i++;
    	}
    	indMid1 = i;
    	i = length-1;
    	while( dataArray[i] < midValue){
    		i--;
    	}
    	indMid2 = i; 
    	int FWHM = indMid2 - indMid1;
    	return FWHM;
    }
    
    
    /*function used to find the changes in the slope
     * 
     *  dir = 1 --> ascending, dir = -1 --> descending
     *  startIndex --> index where the algorithm will start
     *  dataArray
     *  moveDir = 1 --> forward, moveDir = -1 --> backward
     *  numMean --> number of values used to calculate the next mean
     * 
     */
    private int findSlopeChange(int[] dataArray,int startIndex,int dir,int moveDir,int numMean){
    	int currIndex = startIndex; // -5 to adjust for the while loop
    	int currMean = dir; 
    	int prevMean = 0; 
    	//numMean = 10; //number of values used to calculate the next mean
    	while ( (currMean - prevMean)*dir > 0 ){
    		currIndex+=moveDir;
    		prevMean = currMean;
    		currMean = 0;
     		for (int i = 0; i< numMean; i++){
     			//check that i dont get out of the array
     			if ( (currIndex+(i*moveDir) < 256) && (currIndex+(i*moveDir)>0)){
     				currMean += dataArray[currIndex+(i*moveDir)];
     			}
    		}
    		currMean/= numMean;	
    	
    	}
    	return currIndex;
    	
    	
    }
    
    /*
     * function that returns the position of the photopeak and the FWHM for each column in an image
     * data is returned in a single array because imageJ macros does not support multi dimension arrays
     * imgName --> name of the image that will be used
     * slcie --> slice to use, this is added to be able to work with multiSlice images
     * threshold --> thresold from wich to start looking for the maximum
     * numMean --> number of values used to compute the mean on the slope detection algorithm
     */
    private  int[] findMaxPos_FWHM(ImageProcessor imgProc,int nSlice,int threshold,int numMean){

    	//selectImage(imgName);
    	imgProc.setSliceNumber(nSlice);

    	//find the indexes where the values reach the given threshold
    	int width =imgProc.getWidth();
    	int height = imgProc.getHeight();
    	int[] thrsArray = new int[width];
    	thrsArray =  findThresholsdIndex(imgProc,threshold);

    	int[] index1 = new int[width];
    	int[] index2 = new int[width];
    	int[]tmpProfArray = new int[height];

    	//values that I will save
    	int[] minVals = new int[width];
    	int[] maxVals = new int[width];
    	int[] FWHMValues = new int[width];
    	int[] maxPos = new int [width];
    	int minTmp = 0; 
    	int meanTmp = 0;
    	int stdTmp = 0;

    	//array to store the results
    	int[]results = new int[width*2];

    	for (int i = 0; i< width; i++){
    		//first i will get the array of the corresponding crystal
    		
    		//makeLine(i,0,i,height);   		
    		//tmpProfArray = getProfile();
    		imgProc.getColumn(i, 0, tmpProfArray, height);
 
    		index1[i] = findSlopeChange(tmpProfArray, thrsArray[i],1,-1,10);
    		index2[i] = findSlopeChange(tmpProfArray, (index1[i]-30),-1,-1,10);

    		//error check
    		if (((thrsArray[i] - index2[i]) > 0) && (index2[i]>0) ){
    			double[] tmpArrayY = new double[thrsArray[i]- index2[i]];
    			double[] tmpArrayX = new double[thrsArray[i]- index2[i]];
    		
    			//copy only the 511KeV peak to a new array
    			for (int j = 0; j< (thrsArray[i]-index2[i]); j++){
    				tmpArrayY[j] = tmpProfArray[index2[i]+j];
    				tmpArrayX[j] = j;
    			}
    	       		//fit a Guassian curve to it
    	       		//Fit.doFit("GAUSSIAN",tmpArrayX,tmpArrayY);
    	       		CurveFitter cFit = new CurveFitter(tmpArrayX,tmpArrayY);
    	       		cFit.doFit(CurveFitter.GAUSSIAN);
    	       		
    	       		double[] tmpArray = new double[thrsArray[i]-index2[i]];	
    	       		//TODO fix this, using another variable because
    	       		//array util constructor only takes floats....
    	       		float[] tmpsasa = new float[thrsArray[i]-index2[i]];	

    	      		//for (int j = 0; j< (thrsArray[i]- index2[i]); j++){
    	      			//tmpArray[j] = Fit.f(j);
    	     
    			   //}
    	       		//TODO can't type cast to float[]....
    	       		tmpArray = cFit.getYPoints();
    	       		for (int j = 0; j< (thrsArray[i]- index2[i]); j++){
    	       			tmpsasa[j] = (float) tmpArray[j];
    	       		}
    			//now I can find the values that I want
    			minVals[i] =(int) tmpArray[0];
    			//Array.getStatistics(tmpArray, minTmp, maxVals[i], meanTmp, stdTmp);	
    			ArrayUtil aUtil = new ArrayUtil(tmpsasa);
    		    maxVals[i] = (int)aUtil.getMaximum();
    		    meanTmp = (int) aUtil.getMean();
    		    stdTmp = (int) aUtil.getVariance();    		    
    			
    			//FWHMValues[i] = 2.355*Fit.p(3);  //FWHM = 2.355+sigma
    		    double[] fitParams = new double[cFit.getNumParams()];
    		    fitParams = cFit.getParams();
    		    FWHMValues[i] =(int)(2.355*fitParams[3]);
    			//this is done because imageJ curveFitter fails sometimes
    			if (FWHMValues[i] > 150){
    				FWHMValues[i]  = findFWHM(tmpArray, maxVals[i], (thrsArray[i]-index2[i]));
    			}
    		
    		
    			//find the position of maximum value in the profile/energy spectrum
    			int j = 0; 
    			while( tmpArray[j] != maxVals[i]){j++;}
    			maxPos[i] = index2[i]+j;
    		
    		
    		} 

    	
    		//print("Detector "+i+", Máximo "+maxVals[i]+" Pos: "+maxPos[i]+" Mínimo: "+minVals[i]+" FWHM :"+FWHMValues[i]);
    		//now i save the values in one array
    		results[i] = maxPos[i];
    		results[(i+width)] = FWHMValues[i];
    	}
    	
    	return results;
    	
    }
    
    /*
     *  function used to create the minimaps
     *  maxPosMiniMap --> name of the maxPos miniMap image
     *  FWHMMiniMap --> name of the FWHM mini map image
     *  type --> 0 = lyso, 6 = gso
     *  maxPosMap -->maxPos
     */
    private void createMiniMap(ImageProcessor maxPosMiniMap,ImageProcessor FWHMMiniMap,int type,ImageProcessor maxPosMap,ImageProcessor FWHMMap){

    	//selectImage(maxPosMap);
    	int height = maxPosMap.getHeight();
    	int width = maxPosMap.getWidth();
    	
    	int[] profValues1 = new int[height];
    	int[] profValues2 = new int[height];

    	int indYimg =0;
    	int indXimg =0;
    	//
    	//setBatchMode(true);
    	for(int  i = 0; i< width; i++){
    		//selectImage(maxPosMap);
    		//makeLine(i,0,i,height);
    		//profValues1 = getProfile();
    		maxPosMap.getColumn(i, 0, profValues1, height);
    		//selectImage(FWHMMap);
    		//makeLine(i,0,i,height);
    		//profValues2 = getProfile();
    		FWHMMap.getColumn(i, 0, profValues2, height);
    		int currIndex = 0;

            	//plotting the pixels directly to reorder the image as the minimap...
    		indYimg = i%6+type;
    		if(indYimg == type && i > 0){
    			indXimg++;
    		}
    	
    		for(int j = 0; j< 13; j++){
    			for(int k = 0; k<13; k++){		
    				//selectImage(maxPosMiniMap);    				
    				//setPixel((k+(indXimg*14)),(j+(indYimg*14)),profValues1[currIndex]);
    				maxPosMiniMap.putPixel((k+(indXimg*14)),(j+(indYimg*14)),profValues1[currIndex]);

    				//selectImage(FHWMMiniMap);
    				//setPixel((k+(indXimg*14)),(j+(indYimg*14)),profValues2[currIndex]);
    				FWHMMiniMap.putPixel((k+(indXimg*14)),(j+(indYimg*14)),profValues2[currIndex]);
    				currIndex++;			
    			}
    		}
    	
    	}
    	//setBatchMode(false);	
    }
    
}